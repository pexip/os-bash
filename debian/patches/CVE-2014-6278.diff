			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-053

Bug-Reported-by:	Michal Zalewski <lcamtuf@coredump.cx>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

A combination of nested command substitutions and function importing from
the environment can cause bash to execute code appearing in the environment
variable value following the function definition.

Index: bash-4.2.temp/bash/builtins/evalstring.c
===================================================================
--- bash-4.2.temp.orig/bash/builtins/evalstring.c	2014-10-07 11:04:23.614802645 -0400
+++ bash-4.2.temp/bash/builtins/evalstring.c	2014-10-07 11:04:51.262802217 -0400
@@ -261,12 +261,25 @@
 	    {
 	      struct fd_bitmap *bitmap;
 
-	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+	      if (flags & SEVAL_FUNCDEF)
 		{
-		  internal_warning ("%s: ignoring function definition attempt", from_file);
-		  should_jump_to_top_level = 0;
-		  last_result = last_command_exit_value = EX_BADUSAGE;
-		  break;
+		  char *x;
+
+		  /* If the command parses to something other than a straight
+		     function definition, or if we have not consumed the entire
+		     string, or if the parser has transformed the function
+		     name (as parsing will if it begins or ends with shell
+		     whitespace, for example), reject the attempt */
+		  if (command->type != cm_function_def ||
+		      ((x = parser_remaining_input ()) && *x) ||
+		      (STREQ (from_file, command->value.Function_def->name->word) == 0))
+		    {
+		      internal_warning (_("%s: ignoring function definition attempt"), from_file);
+		      should_jump_to_top_level = 0;
+		      last_result = last_command_exit_value = EX_BADUSAGE;
+		      reset_parser ();
+		      break;
+		    }
 		}
 
 	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
@@ -331,7 +344,10 @@
 	      discard_unwind_frame ("pe_dispose");
 
 	      if (flags & SEVAL_ONECMD)
-		break;
+		{
+		  reset_parser ();
+		  break;
+		}
 	    }
 	}
       else
Index: bash-4.2.temp/bash/parse.y
===================================================================
--- bash-4.2.temp.orig/bash/parse.y	2014-10-07 11:04:23.650802645 -0400
+++ bash-4.2.temp/bash/parse.y	2014-10-07 11:04:51.266802217 -0400
@@ -2433,6 +2433,16 @@
     eol_ungetc_lookahead = c;
 }
 
+char *
+parser_remaining_input ()
+{
+  if (shell_input_line == 0)
+    return 0;
+  if (shell_input_line_index < 0 || shell_input_line_index >= shell_input_line_len)
+    return '\0';	/* XXX */
+  return (shell_input_line + shell_input_line_index);
+}
+
 #ifdef INCLUDE_UNUSED
 /* Back the input pointer up by one, effectively `ungetting' a character. */
 static void
@@ -3888,8 +3898,8 @@
   reset_parser ();
   /* reset_parser clears shell_input_line and associated variables */
   restore_input_line_state (&ls);
-  if (interactive)
-    token_to_read = 0;
+
+  token_to_read = 0;
 
   /* Need to find how many characters parse_and_execute consumed, update
      *indp, if flags != 0, copy the portion of the string parsed into RET
Index: bash-4.2.temp/bash/shell.h
===================================================================
--- bash-4.2.temp.orig/bash/shell.h	2014-10-07 11:04:23.158802652 -0400
+++ bash-4.2.temp/bash/shell.h	2014-10-07 11:04:51.266802217 -0400
@@ -177,6 +177,8 @@
 } sh_input_line_state_t;
 
 /* Let's try declaring these here. */
+extern char *parser_remaining_input __P((void));
+
 extern sh_parser_state_t *save_parser_state __P((sh_parser_state_t *));
 extern void restore_parser_state __P((sh_parser_state_t *));
 
